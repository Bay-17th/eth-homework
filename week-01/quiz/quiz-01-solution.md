# Week 1 퀴즈: State/Account + Solidity 기초

**제출 방법:**
1. 이 파일을 복사하여 `quiz-01-solution.md`로 저장
2. 각 문제에 답변 작성 (왜 그런지 설명 포함)
3. Pull Request 생성 (`quiz_submission` 템플릿 사용)

**평가 기준:**
- 정답 여부보다 **개념 이해도**를 중점 평가합니다
- "왜"에 대한 설명이 충분한지 확인합니다
- 문법 오류는 크게 감점하지 않습니다

---

## 문제 1: [이론] 상태 머신 (객관식)

이더리움에서 "상태 전이가 원자적(atomic)이다"라는 말의 의미를 가장 잘 설명한 것은?

다음 상황을 고려하세요:

```
Alice가 Bob에게 1 ETH를 보내는 트랜잭션을 실행합니다.
중간에 가스가 부족해져서 트랜잭션이 실패했습니다.
```

**보기:**
A) Alice의 잔액만 감소하고 Bob의 잔액은 변하지 않는다
B) Alice의 잔액과 Bob의 잔액 모두 변하지 않고, 가스비만 소모된다
C) 네트워크가 자동으로 부족한 가스를 보충해서 트랜잭션을 완료한다
D) 트랜잭션이 절반만 실행되어 0.5 ETH만 전송된다

**답변:**
B) Alice의 잔액과 Bob의 잔액 모두 변하지 않고, 가스비만 소모된다

**설명:**
"원자적(Atomic)"이라는 단어는 **"All or Nothing"**을 의미합니다. 트랜잭션 내부의 여러 작업 중 하나라도 실패하면(가스 부족, 조건 미달 등), 이전의 모든 변경 사항이 없었던 것처럼 **롤백(Rollback)**되어 초기 상태로 돌아갑니다. 하지만 트랜잭션을 실행하기 위해 네트워크 자원을 사용했으므로, 검증자에게 지불하는 가스비는 반환되지 않고 소모됩니다.

---

## 문제 2: [이론] 결정론적 실행 (객관식)

이더리움 EVM이 "결정론적(deterministic)"으로 실행된다는 것의 핵심 이유는 무엇인가요?

**보기:**
A) 모든 노드가 같은 하드웨어를 사용해야 해서
B) 같은 입력(트랜잭션)이 주어지면 모든 노드가 같은 결과(상태)를 도출해야 하므로
C) 중앙 서버가 모든 계산을 수행하고 결과를 배포해서
D) 트랜잭션이 항상 1초 안에 처리되어야 해서

**답변:**
B) 같은 입력(트랜잭션)이 주어지면 모든 노드가 같은 결과(상태)를 도출해야 하므로

**설명:**
블록체인은 분산 시스템입니다. 만약 EVM이 결정론적이지 않아서(예: 현재 시간이나 랜덤 함수 사용) 노드마다 결과가 다르게 나온다면, 네트워크 전체가 하나의 통일된 상태에 도달하는 **'합의(Consensus)'**가 불가능해집니다. 결과가 다르면 하드포크가 발생하거나 네트워크가 멈추게 됩니다.

---

## 문제 3: [이론] EOA vs CA (객관식)

다음 중 EOA(Externally Owned Account)와 CA(Contract Account)의 차이를 올바르게 설명한 것은?

**보기:**
A) EOA는 코드를 실행할 수 있고, CA는 코드를 실행할 수 없다
B) EOA만 트랜잭션을 시작할 수 있고, CA는 EOA에 의해 호출될 때만 실행된다
C) CA만 ETH를 보유할 수 있고, EOA는 ETH를 보유할 수 없다
D) EOA와 CA는 동일한 기능을 가지며 이름만 다르다

**답변:**
B) EOA만 트랜잭션을 시작할 수 있고, CA는 EOA에 의해 호출될 때만 실행된다

**설명:**
트랜잭션을 시작하려면 해당 트랜잭션이 유효하다는 것을 증명하는 **'디지털 서명'**이 필요합니다. 서명은 **개인키(Private Key)**를 가진 주체만이 생성할 수 있는데, EOA는 개인키가 있는 사람이 통제하지만 CA는 개인키 없이 코드에 의해서만 동작합니다. 따라서 CA는 스스로 트랜잭션을 생성(Trigger)할 수 없으며, 반드시 외부의 호출이 있어야만 작동합니다.

---

## 문제 4: [이론] 계정 상태 필드 (객관식)

이더리움 계정 상태의 4가지 필드 중 `nonce`의 역할을 올바르게 설명한 것은?

다음 상황을 고려하세요:

```
Alice의 현재 nonce: 5
Alice가 두 개의 트랜잭션을 동시에 전송합니다:
- TX-A: nonce=5, Bob에게 1 ETH 전송
- TX-B: nonce=5, Charlie에게 2 ETH 전송
```

**보기:**
A) 두 트랜잭션 모두 성공적으로 처리된다
B) TX-A만 처리되고 TX-B는 무시된다 (또는 그 반대)
C) 두 트랜잭션 모두 실패하고 Alice의 자산이 동결된다
D) 네트워크가 자동으로 TX-B의 nonce를 6으로 변경한다

**답변:**
답변: B) TX-A만 처리되고 TX-B는 무시된다 (또는 그 반대)

**설명:**
nonce는 해당 계정에서 보낸 트랜잭션의 순서를 보장합니다. 같은 nonce를 가진 트랜잭션이 두 개 오면, 네트워크는 하나만 선택하고 나머지는 거절합니다.
- `재사용 공격 방지`: 한 번 사용된 nonce는 다시 사용할 수 없으므로, 공격자가 과거의 유효한 송금 트랜잭션을 가로채서 다시 네트워크에 전송(Replay)하더라도 nonce 중복으로 인해 무효 처리됩니다.

---

## 문제 5: [이론] World State (객관식)

World State에 대한 설명 중 올바른 것은?

**보기:**
A) World State는 최신 100개 블록의 트랜잭션만 저장한다
B) World State는 모든 계정의 현재 상태(주소 -> 상태 매핑)를 나타낸다
C) World State는 EOA의 정보만 저장하고 CA 정보는 별도로 관리한다
D) World State는 각 노드마다 다른 값을 가질 수 있다

**답변:**
B) World State는 모든 계정의 현재 상태(주소 -> 상태 매핑)를 나타낸다

**설명:**
World State는 이더리움 전체 네트워크의 **'현재 스냅샷'**입니다. 주소를 입력하면 해당 계정의 잔액, 논스, 코드 등을 바로 찾아볼 수 있는 거대한 매핑 구조이기 때문에, 특정 사람의 정보를 찾기 위해 이름(주소)을 검색하는 **'전화번호부'**에 비유됩니다.

---

## 문제 6: [이론] 상태 변수 vs 지역 변수 (단답형)

Solidity에서 `상태 변수(state variable)`와 `지역 변수(local variable)`의 차이는 무엇인가요?

다음 코드를 보고 설명하세요:

```solidity
contract Example {
    uint256 public count;  // 이것은 무엇인가요?

    function calculate(uint256 input) public pure returns (uint256) {
        uint256 result = input * 2;  // 이것은 무엇인가요?
        return result;
    }
}
```

**답변:**
***`count`(상태 변수)***
* **저장 위치:** 블록체인의 영구적인 저장소인 **Storage**에 저장됩니다.
* **지속성:** 트랜잭션이 끝나도 값이 유지됩니다.
* **비용:** 데이터를 영구히 기록하므로 가스비가 매우 비쌉니다.

***`result`(지역 변수)***
* **저장 위치:** 함수의 실행 환경인 **Memory**나 **Stack**에 일시적으로 저장됩니다.
* **지속성:** 함수 실행이 종료되면 즉시 사라집니다.
* **비용:** 스토리지에 접근하지 않으므로 가스비가 매우 저렴합니다.

---

## 문제 7: [이론] 원자성의 이유 (단답형)

이더리움에서 트랜잭션이 "원자적(atomic)"으로 처리되어야 하는 이유는 무엇인가요?

**왜** 부분적으로 성공하는 트랜잭션을 허용하면 문제가 될까요? 구체적인 예시와 함께 설명하세요.

**답변:**
데이터의 **일관성(Consistency)**을 유지하기 위해서입니다. 만약 송금 트랜잭션에서 "Alice의 잔액 감소"는 성공하고 "Bob의 잔액 증가"는 실패하는 '부분 성공'이 발생하면, 1 ETH가 공중으로 사라지는 심각한 오류가 발생합니다. 이는 화폐 시스템의 신뢰를 무너뜨리므로, 모든 트랜잭션은 반드시 완전히 성공하거나 아예 실행되지 않아야 합니다.

---

## 문제 8: [이론] 계정 구조 설명 (단답형)

EOA에는 `codeHash`와 `storageRoot`가 왜 의미가 없나요?

**답변:**
EOA는 사용자가 개인키로 직접 제어하는 계정으로, 실행할 **코드(codeHash)**가 존재하지 않으며 데이터를 저장할 공간인 **저장소(storageRoot)**도 필요하지 않기 때문입니다. EOA는 오직 잔액(balance)과 거래 순서(nonce) 정보만 관리합니다. 반면 CA는 로직이 담긴 코드와 그 로직을 실행하며 변경되는 변수들을 저장할 공간이 필수적입니다.

---

## 문제 9: [코드] Counter 읽기 (코드 읽기)

다음 Counter.sol 코드를 분석하세요:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

contract Counter {
    uint256 public count;

    function getCount() public view returns (uint256) {
        return count;
    }

    function increment() public {
        count += 1;
    }

    function decrement() public {
        require(count > 0, "Count cannot go below zero");
        count -= 1;
    }
}
```

**1) `public` 키워드의 역할:**
`count` 변수에 `public`이 붙으면 어떤 일이 자동으로 일어나나요?

**답변:**
Solidity 컴파일러가 해당 변수의 값을 외부에서 조회할 수 있는 Getter 함수를 자동으로 생성해 줍니다. 즉, 외부에서 count()라는 이름의 함수를 호출하여 현재 값을 읽어올 수 있게 됩니다.

**2) `view` 키워드의 의미:**
`getCount()` 함수에 `view`가 붙은 이유는 무엇인가요? `view`를 제거하면 어떻게 될까요?

**답변:**
함수가 블록체인의 상태를 '읽기'만 하고 '수정'하지 않음을 보장합니다. view를 제거하면 컴파일러는 이 함수가 상태를 변경할 가능성이 있다고 판단하여 경고를 주거나, 호출 시 불필요하게 가스 소모를 가정할 수 있습니다.

---

## 문제 10: [코드] Counter 동작 예측 (코드 읽기)

위의 Counter 컨트랙트에서 다음 시나리오를 분석하세요:

**시나리오:**
```
초기 상태: count = 0

1. increment() 호출
2. increment() 호출
3. decrement() 호출
4. decrement() 호출
5. decrement() 호출
```

**질문 1:** 5번째 `decrement()` 호출의 결과는 무엇인가요?

**답변:**
- 5번째 decrement() 호출은 **실패(Revert)**합니다.
- 이유: 초기값 0에서 increment 2번(+2), decrement 2번(-2)을 거치면 count는 다시 0이 됩니다. 5번째 호출 시 require(count > 0, ...) 조건을 확인하는데, 0은 0보다 크지 않으므로 에러 메시지와 함께 트랜잭션이 취소됩니다.
* 시작 `count=0`
1. increment → 1
2. increment → 2
3. decrement → 1 (성공)
4. decrement → 0 (성공)
5. decrement → `require(count > 0)`를 만족하지 못해서 **revert로 실패**합니다.
   따라서 5번째 호출은 실패하고, 그 트랜잭션에서의 상태 변화는 없으며(원자성), 가스는 사용됩니다.


**질문 2:** 왜 `decrement()` 함수에 `require(count > 0, ...)` 조건이 필요한가요?

**답변:**
- uint256의 **언더플로우(Underflow)**를 방지하기 위해 필요합니다.
- 이유: uint256은 부호 없는 정수로 0보다 작은 값을 가질 수 없습니다. 만약 0에서 1을 빼려고 하면, Solidity 0.8 버전 이상에서는 에러를 내며 멈추지만, 명시적인 require 문을 통해 사용자에게 정확한 실패 이유(에러 메시지)를 알려주는 것이 좋은 개발 관례입니다.

---

## 자기 평가

모든 문제를 풀었다면, 아래 체크리스트로 자기 평가를 해보세요:

- [x] 상태 머신과 원자성 개념을 이해했다
- [x] EOA와 CA의 차이를 설명할 수 있다
- [x] 계정 상태의 4가지 필드(nonce, balance, storageRoot, codeHash)를 이해했다
- [x] Solidity 기본 문법(public, view, require)을 이해했다
- [x] 상태 변수와 지역 변수의 차이를 설명할 수 있다

---

## 참고 자료

- 이론: `eth-materials/week-01/theory/slides.md`
- 코드: `eth-homework/week-01/dev/src/Counter.sol`
- 용어: `eth-materials/resources/glossary.md`
