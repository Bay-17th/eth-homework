# Week 1 퀴즈: State/Account + Solidity 기초 - 답안

## 문제 1: [이론] 상태 머신 (객관식)

**답변:** B

트랜잭션이 중간에 실패하면 EVM 이 그 트랜잭션으로 바뀐 상태변경을 모두 rollBack 하여 결과적으로 잔액이 똑같게 된다. 하지만 가스비는 연산에 이미 쓰였기 때문에 소모된다.

---

## 문제 2: [이론] 결정론적 실행 (객관식)

**답변:** B

같은 트랜잭션 입력을 받으면 모든 노드가 동일한 실행 결과를 만들어야 네트워크가 하나의 체인에 합의할 수 있습니다.

---

## 문제 3: [이론] EOA vs CA (객관식)

**답변:** B

EOA는 개인키로 서명해서 트랜잭션을 실행할 수 있습니다. 반면 CA는 코드에 의해 동작하지만 개인키가 없어서 서명할 수 없고, 트랜젹선을 실행할 수 없습니다. CA는 EOA의 트랜잭션에 의해 실행됩니다.

---

## 문제 4: [이론] 계정 상태 필드 (객관식)

**답변:** B

동일한 nonce가 5인 TX-A와 TX-B를 동시에 보내면 두 트랜잭션은 둘 다 처리될 수 없고 하나만 유효하게 처리됩니다. nonce는 계정이 보낸 트랜잭션의 순서나 고유성 역할을 하며 이미 처리된 nonce의 트랜잭션을 다시 재전송해도 nonce가 맞지 않아 거부되도록 하여 리플레이 공격을 방지합니다.

---

## 문제 5: [이론] World State (객관식)

**답변:** B

World State는 모든 계정의 현재 상태 매핑입니다. 전화번호부 비유는 이름이나 주소를 찾으면 해당 사람의 현재 정보가 나온다"는 점과 최신 상태를 기준으로 조회 되어서 비슷합니다.

---

## 문제 6: [이론] 상태 변수 vs 지역 변수 (단답형)

uint256 public count: 상태 변수로 컨트랙트의 storage에 저장되어 트랜잭션이 끝나도 값이 유지됩니다

uint256 result: 함수 실행 중에만 존재하는 지역 변수로 보통 memory 놓이며 함수가 끝나면 사라집니다.

---

## 문제 7: [이론] 원자성의 이유 (단답형)

부분 성공을 허용하면 시스템 불변식이 깨져서 상태가 모순됩니다.

---

## 문제 8: [이론] 계정 구조 설명 (단답형)

EOA는 코드가 없고 단순히 키로 제어되는 계정이라서 codeHash는 빈 코드에 해당하는 값으로 사실상 의미가 없고 storageRoot도 비어 있는 상태로 유지됩니다.

---

## 문제 9: [코드] Counter 읽기 (코드 읽기)

**1) `public` 키워드의 역할:**

**답변:** uint256 public count 처럼 상태 변수에 public을 붙이면 컴파일러가 자동으로 count() 같은 getter함수를 생성해 외부에서 값을 조회할 수 있게 해줍니다.

**2) `view` 키워드의 의미:**

**답변:** view는 함수가 상태를 변경하지 않음을 선언해, 컴파일러가 이를 검증하고 다른 컨트랙트에서 호출할 때도 읽기 전용 성격이 명확해집니다.

---

## 문제 10: [코드] Counter 동작 예측 (코드 읽기)

**질문 1:** 5번째 `decrement()` 호출의 결과는 무엇인가요?

**답변:** 실패(revert)합니다. 0에서 두 번 increment() 후 decrement() 두 번을 하면 count가 다시 0이 됩니다. 5번째 decrement()에서는 require() 조건이 거짓이어서 revert 됩니다.

**질문 2:** 왜 `decrement()` 함수에 `require(count > 0, ...)` 조건이 필요한가요?

**답변:** uint256는 음수가 없어서 0에서 1을 빼면 언더플로우 문제가 생깁니다. require를 두면 의도를 명확히 하고,실패 시 기본 panic 대신 에러 메시지로 revert시킬 수 있어 문제 원인을 정확히 알 수 있습니다.
