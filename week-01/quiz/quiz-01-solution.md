# Week 1 퀴즈: State/Account + Solidity 기초

**제출 방법:**
1. 이 파일을 복사하여 `quiz-01-solution.md`로 저장
2. 각 문제에 답변 작성 (왜 그런지 설명 포함)
3. Pull Request 생성 (`quiz_submission` 템플릿 사용)

**평가 기준:**
- 정답 여부보다 **개념 이해도**를 중점 평가합니다
- "왜"에 대한 설명이 충분한지 확인합니다
- 문법 오류는 크게 감점하지 않습니다

---

## 문제 1: [이론] 상태 머신 (객관식)

이더리움에서 "상태 전이가 원자적(atomic)이다"라는 말의 의미를 가장 잘 설명한 것은?

다음 상황을 고려하세요:

```
Alice가 Bob에게 1 ETH를 보내는 트랜잭션을 실행합니다.
중간에 가스가 부족해져서 트랜잭션이 실패했습니다.
```

**보기:**
A) Alice의 잔액만 감소하고 Bob의 잔액은 변하지 않는다
B) Alice의 잔액과 Bob의 잔액 모두 변하지 않고, 가스비만 소모된다
C) 네트워크가 자동으로 부족한 가스를 보충해서 트랜잭션을 완료한다
D) 트랜잭션이 절반만 실행되어 0.5 ETH만 전송된다

**답변:**
정답: B
원자적이라는 말은, 쪼개질 수 없는 하나의 묶음이라는 뜻입니다. 트랜잭션 내의 모든 작업이 전부 완벽하게 실행되거나, 하나라도 실패하면 전체가 취소되어 아무런 상태변경도 일어나지 않는 성질입니다.


---

## 문제 2: [이론] 결정론적 실행 (객관식)

이더리움 EVM이 "결정론적(deterministic)"으로 실행된다는 것의 핵심 이유는 무엇인가요?

**보기:**
A) 모든 노드가 같은 하드웨어를 사용해야 해서
B) 같은 입력(트랜잭션)이 주어지면 모든 노드가 같은 결과(상태)를 도출해야 하므로
C) 중앙 서버가 모든 계산을 수행하고 결과를 배포해서
D) 트랜잭션이 항상 1초 안에 처리되어야 해서

**답변:**
정답:B
이더리움에서는 각 노드가 트랜잭션을 검증할때 똑같이 재실행해서 결과 상태를 확인하게 되는데, 만약 노드A와 B의 계산결과가 다르면 네트워크가 하나의 체인으로 붙지못하고 체인이 분기되거나 네트워크가 영구적으로 분열될 수 있고, 합의의 의미가 사라지게 됩니다. 

---

## 문제 3: [이론] EOA vs CA (객관식)

다음 중 EOA(Externally Owned Account)와 CA(Contract Account)의 차이를 올바르게 설명한 것은?

**보기:**
A) EOA는 코드를 실행할 수 있고, CA는 코드를 실행할 수 없다
B) EOA만 트랜잭션을 시작할 수 있고, CA는 EOA에 의해 호출될 때만 실행된다
C) CA만 ETH를 보유할 수 있고, EOA는 ETH를 보유할 수 없다
D) EOA와 CA는 동일한 기능을 가지며 이름만 다르다

**답변:**
정답:B 
트랜잭션을 시작하려면 전자서명이 있어야 하고, 서명을 하려면 개인키가 있어야 하는데 CA는 코드로만 존재하고 개인키가 없기때문에 스스로 서명을 할 수 없어서 트랜잭션을 시작할 수 없습니다. 

---

## 문제 4: [이론] 계정 상태 필드 (객관식)

이더리움 계정 상태의 4가지 필드 중 `nonce`의 역할을 올바르게 설명한 것은?

다음 상황을 고려하세요:

```
Alice의 현재 nonce: 5
Alice가 두 개의 트랜잭션을 동시에 전송합니다:
- TX-A: nonce=5, Bob에게 1 ETH 전송
- TX-B: nonce=5, Charlie에게 2 ETH 전송
```

**보기:**
A) 두 트랜잭션 모두 성공적으로 처리된다
B) TX-A만 처리되고 TX-B는 무시된다 (또는 그 반대)
C) 두 트랜잭션 모두 실패하고 Alice의 자산이 동결된다
D) 네트워크가 자동으로 TX-B의 nonce를 6으로 변경한다

**답변:**
정답: B
EOA의 논스는 다음 트랜잭션의 순번이고, TX-A와 TX-B중에 더 빨리 도착했거나 가스비가 높은 트랜잭션이 실행되게 되면 그 직후 nonce가 6이 되어버리므로 남겨진 트랜잭션은 폐기됩니다.
논스는 한번 서명된 트랜잭션이 딱 한번만 실행되도록 보장함으로써 이중지불이나 재사용 공격을 원천적으로 차단합니다. 


---

## 문제 5: [이론] World State (객관식)

World State에 대한 설명 중 올바른 것은?

**보기:**
A) World State는 최신 100개 블록의 트랜잭션만 저장한다
B) World State는 모든 계정의 현재 상태(주소 -> 상태 매핑)를 나타낸다
C) World State는 EOA의 정보만 저장하고 CA 정보는 별도로 관리한다
D) World State는 각 노드마다 다른 값을 가질 수 있다

**답변:**

정답: B
world state는 이더리움 네트워크의 모든 EOA, CA 의 구조와 그 계정의 현재 상태를 연결해 둔 데이터 구조입니다. 전화번호부에서 이름을 찾으면 전화번호가 나오는것처럼 worldstate도 계정주소(key)를 입력하면 그 계정의 현재 상태정보(value)를 알려주는 매핑 구조로 되어있기 때문에 전화번호부에 비유됩니다

---

## 문제 6: [이론] 상태 변수 vs 지역 변수 (단답형)

Solidity에서 `상태 변수(state variable)`와 `지역 변수(local variable)`의 차이는 무엇인가요?

다음 코드를 보고 설명하세요:

```solidity
contract Example {
    uint256 public count;  // 이것은 무엇인가요?

    function calculate(uint256 input) public pure returns (uint256) {
        uint256 result = input * 2;  // 이것은 무엇인가요?
        return result;
    }
}
```

**답변:**

count는 상태변수이고 result는 지역변수입니다.
1.저장위치- 상태변수는 블록체인 저장소에 저장되어 블록에 기록되지만 지역변수는 메모리나 스택에 임시로 저장됩니다

2.지속성-상태변수는 트랜잭션이 완료되어도 값이 영구적으로 유지되지만, 지역변수는 함수 실행이 종료되면 소멸됩니다

3.비용- 저장소를 사용하는 상태변수의 변경 비용이 메모리를 사용하는 지역변수보다 훨씬 더 비쌉니다


---

## 문제 7: [이론] 원자성의 이유 (단답형)

이더리움에서 트랜잭션이 "원자적(atomic)"으로 처리되어야 하는 이유는 무엇인가요?

**왜** 부분적으로 성공하는 트랜잭션을 허용하면 문제가 될까요? 구체적인 예시와 함께 설명하세요.

**답변:**

트랜잭션이 원자적이어야 하는 이유는 블록체인 상태의 무결성과 정합성을 유지해야 하기 때문입니다. 
하나의 트랜잭션 내에서 출금이나 입금중 하나만 실행되는 식으로 부분 성공이 허용되면 전체 자산의 총량이 맞지 않거나 데이터가 불일치하는 오류가 발생되게 되고, 프로토콜이 허용하지 않은 EHT 소각, 생성이 일어난것과 같은 상태가 되어버립니다. 

이런 모순이 가능하게 되면 누군가가 의도적으로 증가만 발생시켜서 자산을 부당하게 얻거나, 혹은 감소만 발생시켜서 타인의 자산을 태우는 공격이 가능해져서 전체 시스템의 안전성과 신뢰성이 무너지게 됩니다. 
---

## 문제 8: [이론] 계정 구조 설명 (단답형)

EOA에는 `codeHash`와 `storageRoot`가 왜 의미가 없나요?

**답변:**
<!--
EOA와 CA의 구조적 차이를 설명하면서 답변하세요.
힌트: EOA에 코드가 있나요? 저장소가 필요한가요?
-->
EOA는 사람이 사용하는 계정으로, 스마트 컨트랙트 코드와 상태변수를 전혀 가지고 있지 않기 때문입니다. EOA는 실행할 코드가 없어서 빈 문자열의 해시를 가지고, 변수를 저장할 저장소가 필요하지 않기 때문에 루트값도 비어있게 됩니다.

---

## 문제 9: [코드] Counter 읽기 (코드 읽기)

다음 Counter.sol 코드를 분석하세요:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

contract Counter {
    uint256 public count;

    function getCount() public view returns (uint256) {
        return count;
    }

    function increment() public {
        count += 1;
    }

    function decrement() public {
        require(count > 0, "Count cannot go below zero");
        count -= 1;
    }
}
```

**1) `public` 키워드의 역할:**
`count` 변수에 `public`이 붙으면 어떤 일이 자동으로 일어나나요?

**답변:**
변수앞에 public을 붙이면 솔리디티 컴파일러가 자동으로 그 변수의 값을 조회할 수 있는 getter 함수를 생성해줍니다. 그래서 누구나 counter의 값을 읽을 수 있게 됩니다ㅣ

**2) `view` 키워드의 의미:**
`getCount()` 함수에 `view`가 붙은 이유는 무엇인가요? `view`를 제거하면 어떻게 될까요?

**답변:**
view는 이 함수가 블록체인의 상태(count값)를 읽기만 하고, 절대 수정하지 않는다는것을 말합니다. view가 있으면 외부에서 함수를 호출할때 가스비가 들지 않는다는 특성이 있습니다. 

---

## 문제 10: [코드] Counter 동작 예측 (코드 읽기)

위의 Counter 컨트랙트에서 다음 시나리오를 분석하세요:

**시나리오:**
```
초기 상태: count = 0

1. increment() 호출
2. increment() 호출
3. decrement() 호출
4. decrement() 호출
5. decrement() 호출
```

**질문 1:** 5번째 `decrement()` 호출의 결과는 무엇인가요?

**답변:**

5번째 호출은 실패하게 됩니다. 왜냐하면 4번째 호출까지 마쳤을때 count가 0이 되는데 5번째 decrement() 를 호출했을때 0>0으로 조건문에서 거짓이 되기 때문입니다. 그래서 트랜잭션이 즉시 중단됩니다.


**질문 2:** 왜 `decrement()` 함수에 `require(count > 0, ...)` 조건이 필요한가요?

**답변:**
uint256은 부호 없는 정수타입으로 음수를 가질 수 없습니다. 이 조건이 없으면 0에서 1을 뺄때 언더플로우 오류가 발생하게 됩니다. 그래서 require 을 통해 이런 상황을 미리 방지합니다.
---

## 자기 평가

모든 문제를 풀었다면, 아래 체크리스트로 자기 평가를 해보세요:

- [x] 상태 머신과 원자성 개념을 이해했다
- [x] EOA와 CA의 차이를 설명할 수 있다
- [x] 계정 상태의 4가지 필드(nonce, balance, storageRoot, codeHash)를 이해했다
- [x] Solidity 기본 문법(public, view, require)을 이해했다
- [x] 상태 변수와 지역 변수의 차이를 설명할 수 있다

---

## 참고 자료

- 이론: `eth-materials/week-01/theory/slides.md`
- 코드: `eth-homework/week-01/dev/src/Counter.sol`
- 용어: `eth-materials/resources/glossary.md`
