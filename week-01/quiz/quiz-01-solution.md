# Week 1 퀴즈: State/Account + Solidity 기초

**제출 방법:**
1. 이 파일을 복사하여 `quiz-01-solution.md`로 저장
2. 각 문제에 답변 작성 (왜 그런지 설명 포함)
3. Pull Request 생성 (`quiz_submission` 템플릿 사용)

**평가 기준:**
- 정답 여부보다 **개념 이해도**를 중점 평가합니다
- "왜"에 대한 설명이 충분한지 확인합니다
- 문법 오류는 크게 감점하지 않습니다

---

## 문제 1: [이론] 상태 머신 (객관식)

이더리움에서 "상태 전이가 원자적(atomic)이다"라는 말의 의미를 가장 잘 설명한 것은?

다음 상황을 고려하세요:

```
Alice가 Bob에게 1 ETH를 보내는 트랜잭션을 실행합니다.
중간에 가스가 부족해져서 트랜잭션이 실패했습니다.
```

**보기:**
A) Alice의 잔액만 감소하고 Bob의 잔액은 변하지 않는다
B) Alice의 잔액과 Bob의 잔액 모두 변하지 않고, 가스비만 소모된다
C) 네트워크가 자동으로 부족한 가스를 보충해서 트랜잭션을 완료한다
D) 트랜잭션이 절반만 실행되어 0.5 ETH만 전송된다

**답변:**
<!--
정답 알파벳을 적고, 왜 이 답을 선택했는지 설명하세요.
"원자적"이라는 것이 실제로 어떤 의미인지 설명해 주세요.
-->B. 원자는 물리세계에서 더 이상 쪼갤 수 없는 최소 단위인 것 처럼 상태 전이가 원자적이라는 것은 과정이 쪼개지지 않음을 의미한다. 더 정확히 그 의미를 이해하면 상태를
변화시키는 트랜잭션은 완전히 실행되거나 아니면 완전히 실행되지 않는다. 위의 상태를 살펴보면 중간에 가스가 부족해져 트랜잭션이 실패했기에 완전히 실행되지 않았어야 
한다. 그렇기에 정답은 B이다. 


---

## 문제 2: [이론] 결정론적 실행 (객관식)

이더리움 EVM이 "결정론적(deterministic)"으로 실행된다는 것의 핵심 이유는 무엇인가요?

**보기:**
A) 모든 노드가 같은 하드웨어를 사용해야 해서
B) 같은 입력(트랜잭션)이 주어지면 모든 노드가 같은 결과(상태)를 도출해야 하므로
C) 중앙 서버가 모든 계산을 수행하고 결과를 배포해서
D) 트랜잭션이 항상 1초 안에 처리되어야 해서

**답변:**
<!--
정답과 함께, "결정론적이지 않으면" 어떤 문제가 발생하는지 설명하세요.
예: 노드 A와 노드 B가 다른 결과를 얻으면 어떻게 될까요?
-->B. 이더리움은 분산된 노드들이 독립적으로 실행과 검증을 진행한다. 이때 같은 상태 S와 트랜잭션이 주어졌을 때 동일한 결과인 상태 S'가 보장되어야 하며 이러한 것을
EVM이 결정론적으로 실행된다는 것의 핵심 이유이자 설명이다. 예시와 같이 노드 A와 B가 다른 결과를 얻는다면 독립된 노드 간의 합의는 불가능 할 것 이다.  


---

## 문제 3: [이론] EOA vs CA (객관식)

다음 중 EOA(Externally Owned Account)와 CA(Contract Account)의 차이를 올바르게 설명한 것은?

**보기:**
A) EOA는 코드를 실행할 수 있고, CA는 코드를 실행할 수 없다
B) EOA만 트랜잭션을 시작할 수 있고, CA는 EOA에 의해 호출될 때만 실행된다
C) CA만 ETH를 보유할 수 있고, EOA는 ETH를 보유할 수 없다
D) EOA와 CA는 동일한 기능을 가지며 이름만 다르다
ㅍ
**답변:**
B. EOA는 개인키를 통해 트랜잭션을 생성, 서명할 수 있으며 Eth를 소유, 전송 할 수 있다. CA는 스마트 컨트랙트 계정으로 스스로 트랜잭션을 실행 할 수는 없고, EOA의 호출을
통해 실행된다.


---

## 문제 4: [이론] 계정 상태 필드 (객관식)

이더리움 계정 상태의 4가지 필드 중 `nonce`의 역할을 올바르게 설명한 것은?

다음 상황을 고려하세요:

```
Alice의 현재 nonce: 5
Alice가 두 개의 트랜잭션을 동시에 전송합니다:
- TX-A: nonce=5, Bob에게 1 ETH 전송
- TX-B: nonce=5, Charlie에게 2 ETH 전송
```

**보기:**
A) 두 트랜잭션 모두 성공적으로 처리된다
B) TX-A만 처리되고 TX-B는 무시된다 (또는 그 반대)
C) 두 트랜잭션 모두 실패하고 Alice의 자산이 동결된다
D) 네트워크가 자동으로 TX-B의 nonce를 6으로 변경한다

**답변:**
<!--
정답과 함께, nonce가 "트랜잭션 재사용 공격"을 어떻게 방지하는지 설명하세요.
-->B. nonce는 일종의 변호표 역할을 하며 계정의 현재 nonce와 트랜잭션의 nonce가 다를 시 상태 전이를 막아  중복, 위조등을 방지한다. 현재 Alice의 nonce가 5이며 두개의 
트랜잭션 모두 nonce가 5라면 둘 중 하나의 트랜잭션만 처리되며 나머지 하나의 트랜잭션은 실패한다.


---

## 문제 5: [이론] World State (객관식)

World State에 대한 설명 중 올바른 것은?

**보기:**
A) World State는 최신 100개 블록의 트랜잭션만 저장한다
B) World State는 모든 계정의 현재 상태(주소 -> 상태 매핑)를 나타낸다
C) World State는 EOA의 정보만 저장하고 CA 정보는 별도로 관리한다
D) World State는 각 노드마다 다른 값을 가질 수 있다

**답변:**
<!--
정답과 함께, World State가 "전화번호부"에 비유되는 이유를 설명하세요.
-->B. World State는 EOA, CA등 모든 현재 계정들의 상태를 의미한다. 즉 이더리움 네트워크에 존재하는 모든 계정의 주소를 키로 그 계정의 상태의 묶음이기에 일종의 거대한 
딕셔너리이자 전화번호부라고 볼 수 있다.


---

## 문제 6: [이론] 상태 변수 vs 지역 변수 (단답형)

Solidity에서 `상태 변수(state variable)`와 `지역 변수(local variable)`의 차이는 무엇인가요?

다음 코드를 보고 설명하세요:

```solidity
contract Example {
    uint256 public count;  // 상태 변수

    function calculate(uint256 input) public pure returns (uint256) {
        uint256 result = input * 2;  // 지역 변수
        return result;
    }
}
```

**답변:**
<!--
두 변수의 차이점을 설명하세요.
특히 다음 관점에서 비교해 주세요:
1. 저장 위치 (Storage vs Memory)
2. 지속성 (트랜잭션 종료 후에도 유지되는가?)
3. 비용 (어느 것이 더 비싼가?)
-->상태 변수는 스토리지에 저장되며 트랜잭션이 종료되더라도 영구적으로 저장이되기에 가스비가 상대적으로 높다. 그러나 지역 변수는 함수 내부에서 선언 되어 함수가 실행될때
   메모리에 임시적으로 저장되게에 트랜잭션이 종료되면 저장되지 않는다. 그렇기에 상태 변수에 비해 상대적으로 가스비가 낮다.


---

## 문제 7: [이론] 원자성의 이유 (단답형)

이더리움에서 트랜잭션이 "원자적(atomic)"으로 처리되어야 하는 이유는 무엇인가요?

**왜** 부분적으로 성공하는 트랜잭션을 허용하면 문제가 될까요? 구체적인 예시와 함께 설명하세요.

**답변:**
<!--
2-3 문장으로 설명하세요.
힌트: 송금 트랜잭션이 "절반만 성공"하면 어떤 일이 벌어질까요?
누군가의 잔액이 갑자기 사라지거나 생기면 어떻게 될까요?
--> 


---

## 문제 8: [이론] 계정 구조 설명 (단답형)

EOA에는 `codeHash`와 `storageRoot`가 왜 의미가 없나요?

**답변:**
<!--
EOA와 CA의 구조적 차이를 설명하면서 답변하세요.
힌트: EOA에 코드가 있나요? 저장소가 필요한가요?
-->CA는 코드가 존재하지만 EOA는 코드를 저장하고 있지 않기에 codeHash가 빈 코드의 해쉬값이다. 마찬가지로 CA는 스마트 컨트랙트에 필요한 상태 정보인 스토리지 데이터가
존재하지만 EOA는 스마트 컨트랙트가 존재하지 않기에 비어있다. 


---

## 문제 9: [코드] Counter 읽기 (코드 읽기)

다음 Counter.sol 코드를 분석하세요:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

contract Counter {
    uint256 public count;

    function getCount() public view returns (uint256) {
        return count;
    }

    function increment() public {
        count += 1;
    }

    function decrement() public {
        require(count > 0, "Count cannot go below zero");
        count -= 1;
    }
}
```

**1) `public` 키워드의 역할:**
`count` 변수에 `public`이 붙으면 어떤 일이 자동으로 일어나나요?

**답변:**
<!--
자동 생성되는 것이 무엇인지 설명하세요.
-->변수 count는 상태변수로 public을 통해 자동으로 getter함수가 생성되며 이러한 getter함수의 모습은 아래 getCount함수의 모습과 동일하다. 


**2) `view` 키워드의 의미:**
`getCount()` 함수에 `view`가 붙은 이유는 무엇인가요? `view`를 제거하면 어떻게 될까요?

**답변:**
<!--
view 함수의 특성을 설명하세요.
-->view함수는 읽기 전용 함수로 블록체인의 상태를 변경하지 않고 읽기만을 수행함을 명시한다. 상태를 변경하지 않기에 가스를 소모하지 않는다. view를 제거하더라도 함수의
동작이 변경되지는 않으나 의도가 명확해지지 않는다. 


---

## 문제 10: [코드] Counter 동작 예측 (코드 읽기)

위의 Counter 컨트랙트에서 다음 시나리오를 분석하세요:

**시나리오:**
```
초기 상태: count = 0

1. increment() 호출
2. increment() 호출
3. decrement() 호출
4. decrement() 호출
5. decrement() 호출
```

**질문 1:** 5번째 `decrement()` 호출의 결과는 무엇인가요?

**답변:**
<!--
성공/실패 여부와 그 이유를 설명하세요.
-->"Count cannot go below zero"
decrement()는 count가 0보다 클 시 1을 감소시키는 데 4번째 decrement()때 count값이 0이 되었기에 위와 같이 호출 결과가 뜹니다.

**질문 2:** 왜 `decrement()` 함수에 `require(count > 0, ...)` 조건이 필요한가요?

**답변:**
<!--
이 조건이 없으면 어떤 문제가 발생하는지 설명하세요.
힌트: uint256의 특성을 고려하세요.
-->개발 과제에서 위의 코드를 만들때 @dev에 의하면 count가 0이하일때 1만큼 감소를 시키면 언더플로우가 발생한다고 나와있다. 언더플로우란 변수가 가질 수 있는 최소값보다
작은 값을 부여할 시 발생하는 오류이다. 상태 변수 count의 type이 uint256인데 uint256의 최소값은 0이기에 require()가 필요하다.


---

## 자기 평가

모든 문제를 풀었다면, 아래 체크리스트로 자기 평가를 해보세요:

- [ o ] 상태 머신과 원자성 개념을 이해했다
- [ o ] EOA와 CA의 차이를 설명할 수 있다
- [ o ] 계정 상태의 4가지 필드(nonce, balance, storageRoot, codeHash)를 이해했다
- [ o ] Solidity 기본 문법(public, view, require)을 이해했다
- [ o ] 상태 변수와 지역 변수의 차이를 설명할 수 있다

---

## 참고 자료

- 이론: `eth-materials/week-01/theory/slides.md`
- 코드: `eth-homework/week-01/dev/src/Counter.sol`
- 용어: `eth-materials/resources/glossary.md`
