# Week 1 퀴즈: State/Account + Solidity 기초

**제출 방법:**
1. 이 파일을 복사하여 `quiz-01-solution.md`로 저장
2. 각 문제에 답변 작성 (왜 그런지 설명 포함)
3. Pull Request 생성 (`quiz_submission` 템플릿 사용)

**평가 기준:**
- 정답 여부보다 **개념 이해도**를 중점 평가합니다
- "왜"에 대한 설명이 충분한지 확인합니다
- 문법 오류는 크게 감점하지 않습니다

---

## 문제 1: [이론] 상태 머신 (객관식)

이더리움에서 "상태 전이가 원자적(atomic)이다"라는 말의 의미를 가장 잘 설명한 것은?

다음 상황을 고려하세요:

```
Alice가 Bob에게 1 ETH를 보내는 트랜잭션을 실행합니다.
중간에 가스가 부족해져서 트랜잭션이 실패했습니다.
```

**보기:**
A) Alice의 잔액만 감소하고 Bob의 잔액은 변하지 않는다
B) Alice의 잔액과 Bob의 잔액 모두 변하지 않고, 가스비만 소모된다
C) 네트워크가 자동으로 부족한 가스를 보충해서 트랜잭션을 완료한다
D) 트랜잭션이 절반만 실행되어 0.5 ETH만 전송된다

**답변:**
<!--
정답 알파벳을 적고, 왜 이 답을 선택했는지 설명하세요.
"원자적"이라는 것이 실제로 어떤 의미인지 설명해 주세요.
-->b, 원자적이라는 의미는 트랜잭션의 연산이 블록체인에 반영되도록 완료되든지, 아니면 전혀 반영되지 않도록 rollback되든지인데, 가스가 부족해 트랜잭션이 실패했으면, 트랜잭션이 실행되기 전 상태로 롤백되어야한다. 따라서 절반만 성공하는 중간 상태는 존재할 수 없다. 가스비가 소모되는 이유는 결국 실패한 지점까지 컴퓨팅 자원을 소모했기 때문이다.


---

## 문제 2: [이론] 결정론적 실행 (객관식)

이더리움 EVM이 "결정론적(deterministic)"으로 실행된다는 것의 핵심 이유는 무엇인가요?

**보기:**
A) 모든 노드가 같은 하드웨어를 사용해야 해서
B) 같은 입력(트랜잭션)이 주어지면 모든 노드가 같은 결과(상태)를 도출해야 하므로
C) 중앙 서버가 모든 계산을 수행하고 결과를 배포해서
D) 트랜잭션이 항상 1초 안에 처리되어야 해서

**답변:**
<!--
정답과 함께, "결정론적이지 않으면" 어떤 문제가 발생하는지 설명하세요.
예: 노드 A와 노드 B가 다른 결과를 얻으면 어떻게 될까요?
-->b, 이더리움은 중앙 서버 없이 모든 노드들이 동일한 거래 내역을 공유해야한다. 이를 유지하기 위해서는 언제 어디서 누가 실행하든 입력이 같으면 결과가 같아야 한다. 만약 EVM이 결정론적이지 않으면 각 노드들이 하나의 상태에 합의하지 못하고 fork가 일어날 것이기 때문에 시스템으로서의 신뢰성이 사라진다.


---

## 문제 3: [이론] EOA vs CA (객관식)

다음 중 EOA(Externally Owned Account)와 CA(Contract Account)의 차이를 올바르게 설명한 것은?

**보기:**
A) EOA는 코드를 실행할 수 있고, CA는 코드를 실행할 수 없다
B) EOA만 트랜잭션을 시작할 수 있고, CA는 EOA에 의해 호출될 때만 실행된다
C) CA만 ETH를 보유할 수 있고, EOA는 ETH를 보유할 수 없다
D) EOA와 CA는 동일한 기능을 가지며 이름만 다르다

**답변:**
<!--
정답과 함께, "왜 CA는 트랜잭션을 시작할 수 없나요?"에 대해 설명하세요.
힌트: 트랜잭션을 시작하려면 무엇이 필요한가요?
-->b, EOA는 사람이 관리하며 개인키로 관리된다. 따라서 트랜잭션에 서명을 하여 트랜잭션을 발생시킬 수 있다. CA는 스마트 컨트랙트 코드로 제어되는 계정으로, 개인키가 없다. 따라서 스스로 트랜잭션을 발생시키거나 서명할 수 없다. 따라서 CA는 스스로 작동될 수 없고, EOA의 호출로만 trigger된다. 


---

## 문제 4: [이론] 계정 상태 필드 (객관식)

이더리움 계정 상태의 4가지 필드 중 `nonce`의 역할을 올바르게 설명한 것은?

다음 상황을 고려하세요:

```
Alice의 현재 nonce: 5
Alice가 두 개의 트랜잭션을 동시에 전송합니다:
- TX-A: nonce=5, Bob에게 1 ETH 전송
- TX-B: nonce=5, Charlie에게 2 ETH 전송
```

**보기:**
A) 두 트랜잭션 모두 성공적으로 처리된다
B) TX-A만 처리되고 TX-B는 무시된다 (또는 그 반대)
C) 두 트랜잭션 모두 실패하고 Alice의 자산이 동결된다
D) 네트워크가 자동으로 TX-B의 nonce를 6으로 변경한다

**답변:**
<!--
정답과 함께, nonce가 "트랜잭션 재사용 공격"을 어떻게 방지하는지 설명하세요.
-->b, 이더리움 네트워크는 계정의 현재 nounce와 일치하는 거래만 처리한다. tx-a가 처리되면, nounce값은 6이 되고, tx-b는 거부된다. nounce가 없다면, 트랜잭션 데이터를 계속 복사해서 네트워크에 재전송할 수 있는데, nounce로 인해 이미 처리된 트랜잭션을 구별하여 이중지불 같은 문제를 구조적으로 해결한다. 


---

## 문제 5: [이론] World State (객관식)

World State에 대한 설명 중 올바른 것은?

**보기:**
A) World State는 최신 100개 블록의 트랜잭션만 저장한다
B) World State는 모든 계정의 현재 상태(주소 -> 상태 매핑)를 나타낸다
C) World State는 EOA의 정보만 저장하고 CA 정보는 별도로 관리한다
D) World State는 각 노드마다 다른 값을 가질 수 있다

**답변:**
<!--
정답과 함께, World State가 "전화번호부"에 비유되는 이유를 설명하세요.
-->b, 전화번호부에서 이름을 입력하면 번호가 나오는 것처럼, world state는 계정 주소를 입력하면 그 계정의 현재 상태가 나오는 데이터베이스다. (key,value)로 이루어져 있다. 전화번호부에 친구의 옛날번호까지 다 저장되어있지 않는 것처럼, world state도 모든 거래가 끝난 후의 최종 결과값(잔액은 얼마고, nonce는 몇인지)만을 담고 있다.


---

## 문제 6: [이론] 상태 변수 vs 지역 변수 (단답형)

Solidity에서 `상태 변수(state variable)`와 `지역 변수(local variable)`의 차이는 무엇인가요?

다음 코드를 보고 설명하세요:

```solidity
contract Example {
    uint256 public count;  // 이것은 무엇인가요?

    function calculate(uint256 input) public pure returns (uint256) {
        uint256 result = input * 2;  // 이것은 무엇인가요?
        return result;
    }
}
```

**답변:**
<!--
두 변수의 차이점을 설명하세요.
특히 다음 관점에서 비교해 주세요:
1. 저장 위치 (Storage vs Memory)
2. 지속성 (트랜잭션 종료 후에도 유지되는가?)
3. 비용 (어느 것이 더 비싼가?)
-->상태 변수: 컨트랙트 최상위에 선언되어 블록체인에 영구히 기록/ 저장위치: storage/ 지속성: 트랜잭션 종료시에도 영구적으로 유지/ 비용: 높음
지역 변수: calculate 함수 내부에서 선언되어 함수 실행 중에만 잠시 사용/ 저장 위치:Memory/ 지속성: 함수가 실행될 때만 존재하며 종료시 자동 소멸/ 비용: 가스 거의 들지 않음


---

## 문제 7: [이론] 원자성의 이유 (단답형)

이더리움에서 트랜잭션이 "원자적(atomic)"으로 처리되어야 하는 이유는 무엇인가요?

**왜** 부분적으로 성공하는 트랜잭션을 허용하면 문제가 될까요? 구체적인 예시와 함께 설명하세요.

**답변:**
<!--
2-3 문장으로 설명하세요.
힌트: 송금 트랜잭션이 "절반만 성공"하면 어떤 일이 벌어질까요?
누군가의 잔액이 갑자기 사라지거나 생기면 어떻게 될까요?
-->트랜잭션이 원자적이어야 하는 이유는 데이터의 무결성을 보장하여 자산이 소실되거나 부정하게 생성되는 것을 막기 위해서다.
만약 송금 트랜잭션이 절반만 성공한다면, 보내는 사람의 계좌에서 돈은 빠져나갔는데 받는 사람의 계좌에는 들어오지 않는 치명적인 오류가 발생하여 돈이 소실될 수 있다.
따라서 블록체인은 모든 연산이 완벽하게 완료되거나, 문제가 생기면 아예 실행 전 상태로 원상복구 시킴으로써 장부의 정확성을 유지한다.


---

## 문제 8: [이론] 계정 구조 설명 (단답형)

EOA에는 `codeHash`와 `storageRoot`가 왜 의미가 없나요?

**답변:**
<!--
EOA와 CA의 구조적 차이를 설명하면서 답변하세요.
힌트: EOA에 코드가 있나요? 저장소가 필요한가요?
--> EOA는 단순히 자산을 송수신하는 용도로, 스마트 컨트랙트를 갖고있지 않다. 코드가 없으므로 이를 해시화한 codehash가 필요 없고, 기술적으로 빈 문자열의 해시값으로 설정된다. storageRoot는 스마트 컨트랙트 내의 상태 변수들을 저장하는 공간의 루트값이다. EOA는 코드가 없기 때문에 데이터를 영구적으로 저장할 변수나 저장 공간 자체가 필요하지 않다. 따라서 저장할 데이터가 없으므로 storageRoot 또한 빈 값을 가진다.


---

## 문제 9: [코드] Counter 읽기 (코드 읽기)

다음 Counter.sol 코드를 분석하세요:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

contract Counter {
    uint256 public count;

    function getCount() public view returns (uint256) {
        return count;
    }

    function increment() public {
        count += 1;
    }

    function decrement() public {
        require(count > 0, "Count cannot go below zero");
        count -= 1;
    }
}
```

**1) `public` 키워드의 역할:**
`count` 변수에 `public`이 붙으면 어떤 일이 자동으로 일어나나요?

**답변:**
<!--
자동 생성되는 것이 무엇인지 설명하세요.
-->count()라는 이름의 함수가 만들어진다. 이 함수는 매개변수를 받지 않고, 현재 count 변수에 저장된 값을 리턴하는 역할만 수행한다. external view 속성을 가지므로, 컨트랙트 외부에서 누구나 count의 값을 읽을 수 있게 된다.


**2) `view` 키워드의 의미:**
`getCount()` 함수에 `view`가 붙은 이유는 무엇인가요? `view`를 제거하면 어떻게 될까요?

**답변:**
<!--
view 함수의 특성을 설명하세요.
-->view는 해당 함수가 블록체인의 상태를 읽기만 하고, 절대 변경하지 않겠다는 것을 명시하는 키워드이다. getCount() 함수는 count 변수의 값을 가져오기만 할 뿐, 값을 수정하거나 쓰지 않기 때문에 view를 사용한다. view를 제거하면 컴파일러가 해당 함수는 상태를 변경하지 않으니 view를 붙이기를 경고한다. view는 외부에서 호출시에 가스비가 무료인데, 제거된다면 함수가 상태를 변경할 가능성이 있다고 판단되어 트랜잭션으로 처리될 수 있으며, 불필요한 가스비가 청구될 수 있다.


---

## 문제 10: [코드] Counter 동작 예측 (코드 읽기)

위의 Counter 컨트랙트에서 다음 시나리오를 분석하세요:

**시나리오:**
```
초기 상태: count = 0

1. increment() 호출
2. increment() 호출
3. decrement() 호출
4. decrement() 호출
5. decrement() 호출
```

**질문 1:** 5번째 `decrement()` 호출의 결과는 무엇인가요?

**답변:**
<!--
성공/실패 여부와 그 이유를 설명하세요.
-->실패한다. 4번째 decrement호출시에 count 는 0 이된다. 5번째 호출시에 require줄이 실행되어 해당 조건은 거짓이 된다. 따라서 트랜잭션은 즉시 종료되고 이전 상태로 롤백되며 Count cannot go below zero 메시지를 출력한다.


**질문 2:** 왜 `decrement()` 함수에 `require(count > 0, ...)` 조건이 필요한가요?

**답변:**
<!--
이 조건이 없으면 어떤 문제가 발생하는지 설명하세요.
힌트: uint256의 특성을 고려하세요.
-->uint256타입은 음수가 될 수 없다. 이 조건이 없으면 underflow될 수 있다. 만약 require 없이 0 - 1을 수행하게 되면 언더플로우를 자동으로 감지하여 트랜잭션을 강제로 실패시키지만, 왜 실패했는지는 알려주지 않는다.
따라서, require를 사용하면 0 밑으로 내려가서 실패했다는 명확한 이유를 사용자에게 알려주고, 논리적인 오류를 사전에 안전하게 막을 수 있다.


---

## 자기 평가

모든 문제를 풀었다면, 아래 체크리스트로 자기 평가를 해보세요:

- [o] 상태 머신과 원자성 개념을 이해했다
- [o] EOA와 CA의 차이를 설명할 수 있다
- [o] 계정 상태의 4가지 필드(nonce, balance, storageRoot, codeHash)를 이해했다
- [o] Solidity 기본 문법(public, view, require)을 이해했다
- [o] 상태 변수와 지역 변수의 차이를 설명할 수 있다

---

## 참고 자료

- 이론: `eth-materials/week-01/theory/slides.md`
- 코드: `eth-homework/week-01/dev/src/Counter.sol`
- 용어: `eth-materials/resources/glossary.md`
