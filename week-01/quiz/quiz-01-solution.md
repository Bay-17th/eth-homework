# Week 1 퀴즈: State/Account + Solidity 기초

**제출 방법:**
1. 이 파일을 복사하여 `quiz-01-solution.md`로 저장
2. 각 문제에 답변 작성 (왜 그런지 설명 포함)
3. Pull Request 생성 (`quiz_submission` 템플릿 사용)

**평가 기준:**
- 정답 여부보다 **개념 이해도**를 중점 평가합니다
- "왜"에 대한 설명이 충분한지 확인합니다
- 문법 오류는 크게 감점하지 않습니다

---

## 문제 1: [이론] 상태 머신 (객관식)

이더리움에서 "상태 전이가 원자적(atomic)이다"라는 말의 의미를 가장 잘 설명한 것은?

다음 상황을 고려하세요:

```
Alice가 Bob에게 1 ETH를 보내는 트랜잭션을 실행합니다.
중간에 가스가 부족해져서 트랜잭션이 실패했습니다.
```

**보기:**
A) Alice의 잔액만 감소하고 Bob의 잔액은 변하지 않는다
B) Alice의 잔액과 Bob의 잔액 모두 변하지 않고, 가스비만 소모된다
C) 네트워크가 자동으로 부족한 가스를 보충해서 트랜잭션을 완료한다
D) 트랜잭션이 절반만 실행되어 0.5 ETH만 전송된다

**답변:**
<!--
정답 알파벳을 적고, 왜 이 답을 선택했는지 설명하세요.
"원자적"이라는 것이 실제로 어떤 의미인지 설명해 주세요.
-->
B
이더리움 트랜잭션은 성공하면 모두 반영되고, 실행 도중 에러가 발생(실패하면)하면 이전 상태로 롤백된다. 이러한 특성을 원자적이라고 부르며 A, C, D는 이에 해당하지 않는다.

---

## 문제 2: [이론] 결정론적 실행 (객관식)

이더리움 EVM이 "결정론적(deterministic)"으로 실행된다는 것의 핵심 이유는 무엇인가요?

**보기:**
A) 모든 노드가 같은 하드웨어를 사용해야 해서
B) 같은 입력(트랜잭션)이 주어지면 모든 노드가 같은 결과(상태)를 도출해야 하므로
C) 중앙 서버가 모든 계산을 수행하고 결과를 배포해서
D) 트랜잭션이 항상 1초 안에 처리되어야 해서

**답변:**
<!--
정답과 함께, "결정론적이지 않으면" 어떤 문제가 발생하는지 설명하세요.
예: 노드 A와 노드 B가 다른 결과를 얻으면 어떻게 될까요?
-->
B
EVM이 결정론적이지 않아서 노드마다 결과가 다르게 나오면 네트워크는 어떤 결과가 맞는지 합의할 수 없게 된다. 따라서 합의 실패로 이어져 체인이 분열되거나 네트워크의 신뢰성을 잃게 된다.

---

## 문제 3: [이론] EOA vs CA (객관식)

다음 중 EOA(Externally Owned Account)와 CA(Contract Account)의 차이를 올바르게 설명한 것은?

**보기:**
A) EOA는 코드를 실행할 수 있고, CA는 코드를 실행할 수 없다
B) EOA만 트랜잭션을 시작할 수 있고, CA는 EOA에 의해 호출될 때만 실행된다
C) CA만 ETH를 보유할 수 있고, EOA는 ETH를 보유할 수 없다
D) EOA와 CA는 동일한 기능을 가지며 이름만 다르다

**답변:**
<!--
정답과 함께, "왜 CA는 트랜잭션을 시작할 수 없나요?"에 대해 설명하세요.
힌트: 트랜잭션을 시작하려면 무엇이 필요한가요?
-->
B
이더리움에서 모든 트랜잭션은 개인키를 가진 주체의 디지털 서명으로부터 시작되어야 한다. CA는 개인키가 없으므로 스스로 서명을 만들 수 없다. 

---

## 문제 4: [이론] 계정 상태 필드 (객관식)

이더리움 계정 상태의 4가지 필드 중 `nonce`의 역할을 올바르게 설명한 것은?

다음 상황을 고려하세요:

```
Alice의 현재 nonce: 5
Alice가 두 개의 트랜잭션을 동시에 전송합니다:
- TX-A: nonce=5, Bob에게 1 ETH 전송
- TX-B: nonce=5, Charlie에게 2 ETH 전송
```

**보기:**
A) 두 트랜잭션 모두 성공적으로 처리된다
B) TX-A만 처리되고 TX-B는 무시된다 (또는 그 반대)
C) 두 트랜잭션 모두 실패하고 Alice의 자산이 동결된다
D) 네트워크가 자동으로 TX-B의 nonce를 6으로 변경한다

**답변:**
<!--
정답과 함께, nonce가 "트랜잭션 재사용 공격"을 어떻게 방지하는지 설명하세요.
-->
B
이더리움의 각 트랜잭션은 계정별로 고유하고 순차적인 nonce값을 가져야 한다. 동일한 nonce를 가진 트랜잭션이 동시에 전송되면 네트워크는 그중 하나만 유효한 것으로 처리한다. 한번 사용된 nonce는 다시 사용할 수 없으므로, 트랜잭션 재사용 공격을 해도 nonce중복을 감지하여 방어한다.

---

## 문제 5: [이론] World State (객관식)

World State에 대한 설명 중 올바른 것은?

**보기:**
A) World State는 최신 100개 블록의 트랜잭션만 저장한다
B) World State는 모든 계정의 현재 상태(주소 -> 상태 매핑)를 나타낸다
C) World State는 EOA의 정보만 저장하고 CA 정보는 별도로 관리한다
D) World State는 각 노드마다 다른 값을 가질 수 있다

**답변:**
<!--
정답과 함께, World State가 "전화번호부"에 비유되는 이유를 설명하세요.
-->
B
World State는 이더리움에 존재하는 모든 계정 주소와 그에 대응하는 상태값을 연결해 놓은 전체 네트워크의 지도이다. 전화번호부에서 이름을 찾으면 대응하는 번호가 나오듯이, World State에서도 계정 주소를 찾으면 해당하는 계정의 상태값이 조회 가능하기 때문에 전화번호부로 비유된다.

---

## 문제 6: [이론] 상태 변수 vs 지역 변수 (단답형)

Solidity에서 `상태 변수(state variable)`와 `지역 변수(local variable)`의 차이는 무엇인가요?

다음 코드를 보고 설명하세요:

```solidity
contract Example {
    uint256 public count;  // 이것은 무엇인가요?

    function calculate(uint256 input) public pure returns (uint256) {
        uint256 result = input * 2;  // 이것은 무엇인가요?
        return result;
    }
}
```

**답변:**
<!--
두 변수의 차이점을 설명하세요.
특히 다음 관점에서 비교해 주세요:
1. 저장 위치 (Storage vs Memory)
2. 지속성 (트랜잭션 종료 후에도 유지되는가?)
3. 비용 (어느 것이 더 비싼가?)
-->
count는 상태 변수고, result는 지역 변수다. 상태 변수는 블록체인의 영구적인 저장소인 Storage에 기록되고, 지역 변수는 함수 실행 중에만 존재하는 Memory에 임시로 저장된다. 상태 변수는 트랜잭션 종료 후에도 값이 유지되지만 지역 변수는 함수 실행이 끝나면 사라진다. 상태 변수는 데이터를 블록체인에 영구적으로 저장하고 지역 변수는 메모리에 임시로 저장하기 때문에 가스비는 상태변수>지역변수 이다.

---

## 문제 7: [이론] 원자성의 이유 (단답형)

이더리움에서 트랜잭션이 "원자적(atomic)"으로 처리되어야 하는 이유는 무엇인가요?

**왜** 부분적으로 성공하는 트랜잭션을 허용하면 문제가 될까요? 구체적인 예시와 함께 설명하세요.

**답변:**
<!--
2-3 문장으로 설명하세요.
힌트: 송금 트랜잭션이 "절반만 성공"하면 어떤 일이 벌어질까요?
누군가의 잔액이 갑자기 사라지거나 생기면 어떻게 될까요?
-->
이더리움 트랜잭션이 원자적이어야 하는 이유는 데이터의 일관성과 신뢰성을 지키기 위해서이다. 원자성이 없다면 송금같은 트랜잭션이 절반만 실행되고, 이는 전체 네트워크의 경제적 무결성을 파괴한다. 그렇기 때문에 모든 단계가 완벽히 성공하거나, 하나라도 실패하면 아예 시작 전으로 롤백해야한다.

---

## 문제 8: [이론] 계정 구조 설명 (단답형)

EOA에는 `codeHash`와 `storageRoot`가 왜 의미가 없나요?

**답변:**
<!--
EOA와 CA의 구조적 차이를 설명하면서 답변하세요.
힌트: EOA에 코드가 있나요? 저장소가 필요한가요?
-->
EOA는 사람이 관리하는 개인용 지갑이기 때문이다. codeHash의 경우 EOA는 실행할 스마트 컨트랙트 코드가 없으므로 빈 문자열의 해시값을 갖는다. sotrageRoot의 경우 EOA는 별도의 Storage를 가지지 않고 잔액과 논스 정보만 관리하므로 의미가 없다. 하지만 CA는 계약의 상태를 저장해야 하므로 이 값들이 필수적이다.

---

## 문제 9: [코드] Counter 읽기 (코드 읽기)

다음 Counter.sol 코드를 분석하세요:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

contract Counter {
    uint256 public count;

    function getCount() public view returns (uint256) {
        return count;
    }

    function increment() public {
        count += 1;
    }

    function decrement() public {
        require(count > 0, "Count cannot go below zero");
        count -= 1;
    }
}
```

**1) `public` 키워드의 역할:**
`count` 변수에 `public`이 붙으면 어떤 일이 자동으로 일어나나요?

**답변:**
<!--
자동 생성되는 것이 무엇인지 설명하세요.
-->
상태 변수에 public을 붙이면 해당 변수의 값을 외부에서 읽을 수 있는 Getter함수가 자동으로 생성된다. 즉 별도로 getCount()를 만들지 않아도 외부에서 count()라는 이름으로 조회할 수 있다.

**2) `view` 키워드의 의미:**
`getCount()` 함수에 `view`가 붙은 이유는 무엇인가요? `view`를 제거하면 어떻게 될까요?

**답변:**
<!--
view 함수의 특성을 설명하세요.
-->
view 키워드는 함수가 블록체인의 상태를 읽기만 하고 수정하지 않음을 뜻한다. 만약 view를 제거하면 컴파일러는 이 함수가 상태를 바꿀 가능성이 있다고 판단하여 가스비 계산 방식 등이 달라질 수 있고, 읽기 전용 함수임을 명확히 알 수 없다.

---

## 문제 10: [코드] Counter 동작 예측 (코드 읽기)

위의 Counter 컨트랙트에서 다음 시나리오를 분석하세요:

**시나리오:**
```
초기 상태: count = 0

1. increment() 호출
2. increment() 호출
3. decrement() 호출
4. decrement() 호출
5. decrement() 호출
```

**질문 1:** 5번째 `decrement()` 호출의 결과는 무엇인가요?

**답변:**
<!--
성공/실패 여부와 그 이유를 설명하세요.
-->
실패한다. 2번 호출이 끝나고 count는 2가 되고, 4번 호출이 끝나고 count는 0이 된다. 5번이 호출될 때 count는 0이므로 count > 0조건에 걸려 트랜잭션이 취소된다.

**질문 2:** 왜 `decrement()` 함수에 `require(count > 0, ...)` 조건이 필요한가요?

**답변:**
<!--
이 조건이 없으면 어떤 문제가 발생하는지 설명하세요.
힌트: uint256의 특성을 고려하세요.
-->
uint256은 부호가 없는 정수형이므로 양수여야 한다. require조건이 없으면 0에서 1을 뺄때 언더플로우 에러가 발생하여 아주 큰 양수로 변하는 등의 논리 오류가 생길 수 있다.

---

## 자기 평가

모든 문제를 풀었다면, 아래 체크리스트로 자기 평가를 해보세요:

- [v] 상태 머신과 원자성 개념을 이해했다
- [v] EOA와 CA의 차이를 설명할 수 있다
- [v] 계정 상태의 4가지 필드(nonce, balance, storageRoot, codeHash)를 이해했다
- [v] Solidity 기본 문법(public, view, require)을 이해했다
- [v] 상태 변수와 지역 변수의 차이를 설명할 수 있다

---

## 참고 자료

- 이론: `eth-materials/week-01/theory/slides.md`
- 코드: `eth-homework/week-01/dev/src/Counter.sol`
- 용어: `eth-materials/resources/glossary.md`
